# Design document

## Список разработчиков

- Жемчужина Елизавета
- Кириллова Евгения
- Сунко Елена
- Иценко Екатерина

## Общие сведения о системе
### Назначение

Система представляет из себя реализацию roguelike игры **Escape** с консольной графикой. Система предназначена для развлечения и отдыха.

### Границы системы
- Поддерживается только однопользовательский оффлайн режим игры
- Консольная графика
- Управление производится с клавиатуры заранее заданными клавишами
- Предусмотрено главное меню с тремя опциями:

  - Начать игру (_play_)
  - Начать игру с загрузкой уровней из файла (_play_with_levels_from_config_files_)
  - Выйти из игры (_exit_)
  - Посмотреть подсказки по управлению (_help_)
- Текущая локация (или поле) представляет из себя прямоугольное поле в декартовой системе координат
- Текущее поле отображается на экране целиком
- На начальном этапе случайно генерируется расположение части ресурсов и препятствий для отдельных уровней
- Помимо игрового поля на экране отображаются панели с ресурсами, здоровьем и инвентарем
- Отсутствуют контрольные точки (сохранения)

#### Правила игры
Задача игрока - пройти все уровни. Уровней 5, если они сгенерированы приложением, и неограниченное количество, если пользователь предоставляет их самостоятельно.

Каждому уровню соответствует одна локация, представляющая из себя прямоугольное поле. В клетке поля может находиться:
- Препятствие: игрок ступить на данную клетку не может.
- Враг: в случае, если игрок оказывается в окрестности врага (то есть на одну клетку справа, снизу, сверху или по диагонали), враг атакует игрока. Урон зависит от типа врага:
  - Враг первого типа: двигается всегда только по диагонали или вертикали, его траектория всегда одна и та же. Наносит меньший урон.
  - Враг второго типа: двигается случайным образом, наносит больший урон.
- Очки
- Инвентарь:
  - Инвентарь атаки: когда на игроке надет данный инвентарь, игрок может убирать препятствия (но не врагов).
  - Инвентарь защиты: когда на игроке надет данный инвентарь, урон от врагов становится меньше.
- Укрытие: у каждого укрытия есть определенный цвет. Укрытия одного цвета соответствуют одному типу.
  - Настоящее укрытие: при нахождении на клетке данного укрытия игрок находится в безопасности (враг не может его атаковать)
  - Ложное урытие: при наступление на клетку игрок теряет жизнь

Уровень считается пройденным, как только игрок набирает нужное число очков. На прохождение каждого уровня выделяется определенное число секунд, если игрок не успел собрать все очки до истечения таймера, он автоматически проиграл.

У игрока есть заданное в начале игры число жизней, которое по тем или иным причинам может уменьшаться в течение игры. Когда число жизней становится равно 0, игрок автоматически проигрывает.

Для передвижения персонажа игрок должен использовать стрелки left, up, right, down. Кнопка enter при наличии инвентаря атаки позволяет атаковать препятствия в окрестности игрока (если их несколько, то сразу все). Кнопка shift позволяет переключаться между инвентарем.
### Контекст

- Приложение не поддерживает взаимодействие с сервером
- Приложение адаптировано под Linux, MacOS и Windows

## Architectural drivers
### Технические ограничения
Должна быть предусмотрена библиотека для работы с консолью, работающая под упомянутыми операционными системами.

### Бизнес-ограничения

- Срок разработки ограничен несколькими месяцами
- В силу отсутствия бюджета, используются бесплатные фреймворки и библиотеки

### Качественные характеристики системы

- Система должна быть достаточно гибкой для дальнейшей расширяемости, то есть необходимость в изменении установленных границ при добавлении или модификации сущностей отсутствует. Например, должна быть возможность добавления новых персонажей
- Платформозависимые части системы необходимо выделять в отдельные компоненты
- В дальнейшем планируется сделать проект open source, поэтому простота сопровождаемости системы превалирует над производительностью
- В системе не происходит взаимодействия с личными данными пользователей, поэтому обеспечение безопасности не является приоритетной задачей
- При генерации и отрисовке уровней используются простые инструменты (такие как консольная графика), поэтому обеспечение высокой производительности не требуется

### Ключевые функциональные требования

- Управление производится с клавиатуры
- Игрок управляет одним персонажем
- Персонаж взаимодействует с полем и объектами на нем (ресурсы, инвентарь и пр.)
- Имеется возможность подгружать карту текущей локации из файла
- Консольная графика

## Architectural views
### Роли и случаи использования

#### Роли
- Игрок
- Программист, дорабатывающий проект после перехода в стадию open source

#### Случаи использования
- Игрок хочет максимально разнообразным количеством способов пройти игру, поэтому количество вариантов взаимодействия игрока с внутриигровыми объектами должно быть большим
- Игрок не хочет находиться в одной локации долго, поэтому уровни должны быть короткими
- Среднестатистический игрок не обладает средствами на покупку игрового компьютера, поэтому простота графики приветствуется
- Программист не хочет разбираться во всем коде целиком, поэтому система должна быть спроектирована так, чтобы взаимодействие велось только с точками расширения проекта

#### Типичный пользователь
<img src="images/gosling.jpg"/>

Это Райан.

Он прекрасен, поэтому его возраст не так важен (но вообще ему 41).

Он не является заядлым геймером, поэтому ему хочется, чтобы управление было максимально простым.

Его хобби - это работа в консоли, но иногда он устает от бесконечного изучения MAN'ов и ему хочется разнообразия.

### Композиция
<img src="images/components.png"/>

Используется классическая слоистая архитектура, основной акцент сделан на выделение компонент в соответствии
с архитектурным стилем **MVC**


#### Описаниe:

**Controller**:

- `input component` - отвечает за обработку пользователя
- `interaction component` - отвечает за связь с остальными подсистемами

**Model**:

- `characterManager component` - отвечает за все связанное с игроками
- `levelManager component` - отвечает за все связанное с уровнями
- `gameManager component` - отвечает за связь уровней и в целом за всю игру

**View**

- `ApplicationView component` - отрисовка главного меню
- `GameRulesView component` - отрисовка правил
- `GameView component` - отрисовка самой игры

### Логическая структура

#### Controller
Связь между компонентами и обработка комманд пользователя.
##### class Application

Точка входа в приложение и начала игры.

**Методы**:

+ `startApplication(String)` - начинает работу приложения. На вход принимает путь до директории с конфигурационными файлами, описывающими уровни игры.

Внутри создается цикл, в котором при помощи средств библиотеки для работы с графикой считывается ввод пользователя, который далее передается в `InteractionManager`


##### classItemHolder

**Поля**:

- `List<SelectedItem> allItems` - список всех доступных опций
- `int currentItemNumber` - индекс текущей опции в списке

**Методы**:

- `setSelectedItem(InputCommand inputCommand)` - меняет текущую опцию в зависимости от введенной команды
- `SelectedItem getCurrentItem()` - возвращает текущую опцию

##### class InteractionManager
Зона ответственности включает в себя все действия пользователя вне самого игрового процесса, то есть
действия на начальном экране (запрос на начало игры, запрос вывода правил, запрос на выход из приложения),
а так же на экране с правилами игры.

**Поля**:

- `applicationView: ApplicationView` - необходим для отрисовки первоначального экрана и выделение опций на нем.

- `gameRulesView: ApplicationView` - необходим для отрисовки правил игры.

- `Screen screen` - ткущее состояние приложения

- `ItemHolder itemHolder` - хранит информацию о текущей опции в главном меню, осуществляет смену опций

- `Game game` - объект игры

- `boolean isRunning` - `true` пока пользователь не выбрал опцию `exit`

**Методы**:

+ `processCommand(InputCommand inputCommand)` - данный метод вызывается каждый раз при введении пользователем той
или иной команды (по сути нажатием той или иной клавиши). В зависимости от команды и текущей выделенной
опции может показать правила игры, осуществить выход из приложения, начать игру, выделить другую опцию.

##### enumeration SelectedItem
Опции главного экрана, одна из которых выделена в любой момент времени.

**Элементы**
- `Game`
- `Rules`
- `MainMenu`

##### enumeration Action
Отвечает за некоторое действие, совершенное в игре игроком.
**Элементы**

- `Destroy`
- `MoveLeft`
- `MoveRight`
- `MoveUp`
- `MoveDown`
- `ChangeEquiption`.

##### Диаграмма:
<img src="images/controller_component.png"/>

#### Model

Реализация основной логики игры

##### interface Action

Возможное действие игрока на поле

**Поля**:

  - `String type` - тип действия

**Реализации**:

- `Attack`
- `MoveLeft`
- `MobeRight`
- `MoveUp`
- `MoveDown`
- `ChangeEquiption`

##### enum Result

**Элементы**:

- `victory`
- `defeat`
- `isRunning`


##### class Game

Запускает игру, выполняет смену уровней в ней

**Поля**:

- `LevelGenerator levelGenerator` - используется для генерации нового уровня
- `Level currentLevel` - текущий уровень, на котором находится игрок


**Конструкторы**:

- `Game(String levelFilesPath)` - принимает директорию, в которой расположены файлы, созданные пользователем
для генерации уровней. В случае, если директория пользователем не задана, `levelFilespath = ""`

**Методы**:

- `Result startGame(boolean generateLevelsFromFile)` - функция запуска игры. Пока игрок не дошел до конца или не проиграл на каком-то
из уровней, создает новый уровень, по завершению предыдущего. В конце возвращает результат игры
- `void makeAction(Action)` - выполняет поступившее на вход действие, вызвав нужный метод у `currentLevel`

##### enum InventoryItem

**Элементы**:
  - `attack` - дает игроку возможность ломать препятствия
  - `protection` - уменьшает урон от атаки врага

##### class Backpack

Рюкзак персонажа

**Поля**:
- `activeItem` - инвентарь, которым на данный момент пользуется игрок. В случае, если игрок ничем не пользуется, `activeItem = null`
- `List<Inventory> allItems` - список вещей, которые есть у игрока

##### interface Character

Интерфейс, описывающий объект, находящийся на полеEmpty

**Реализации**:

- **class Player**: враг, раз в какое-то время двигается и атакует игрока

  Методы: 
  - `Pair<int, int> makeNextMove()` - возвращает координаты, на которые должен передвинуться
  - `void attack(Player)` - атакует игрока
- **class Player**: игрок, управляется пользователем
  
  Поля:
  - `int lives` - оставшееся количество жизней
  - `int points` - собранное количество очков
  - `Backpack backpack` - рюкзак игрока

  Методы:
  - `boolean canAttack()` - если у игрока в рюкзаке есть инвентарь, увеличивающий силу удара, возвращает `true`, иначе `false`
  - `void decreaseLives()` - при атаке уменьшает количество жизней, в зависимости от содержимого рюкзака может уменьшать на разное число
- **class Obstacle**: препятствие на поле, может быть разрушено игроком при наличии нужного инвентаря в рюкзаке
- **class Points**: очки, которые нужно собирать игроку для того, чтобы выиграть
- **class Shetter**: убежище, в котором может прятаться игрок от атак врагов

  Поля:
  - `String type` - тип убежища
- **class Empty**: пустая клетка поля
- **class Inventory**: инвентарь

  Поля:
  - `InventoryItem type` - тип инвентаря


##### abstract class LevelCharacteristic

Класс для предоставления информации о том, что должно быть на рандомно сгенерированном уровне

**Поля**:

- `int xSize, int ySize` - размеры доски
- `Map<CharacterType, int> characters` - информация о том сколько объектов какого типа должно быть на поле
- `List<Pair<int, int>> emptyCells` - список еще не занятых клеток, в которые можно помещать объекты при рандомной генерации

**Наследники**:

- **class FirstLevelCharacteristic**
- **class SecondLevelCharacteristic**
- **class ThirdLevelCharacteristic**
- **class FourthLevelCharacteristic**
- **class FifthLevelCharacteristic**

##### class LevelGenerator

Генерирует уровни рандомно или из файла

**Поля**:

- `Optional<String> filesPath` - директория в которой лежат файлы для генерации уровней
- `int levelNumber` - номер уровня, который надо сгенерировать
- `List<LevelCharacteristics> levelCharacteristics` - список заданных параметров для уровней, 
если генерация будет происходить рандомно

**Методы**:

- `boolean hasNextLevel()` - если уровни генерируются рандомно, то проверяет, сгенерировано ли на данный момент
меньше 5 уровней, если да, то возвращает `true`, иначе `false`. Если уровни генерируются из файлов пользователей, то
проверяет, что есть еще не использованные файлы
- `Level nextLevel()` - генерирует следующий уровень

##### class Level

Реализует взаимодействия объектов на одном уровне

**Поля**:

- `Character[][] board` - поле. В клетке находится текущий `Character`
- `Map<Enemy, Pair<int, int> characters` - враги, которые есть на поле
- `GameView gameView` - объект для отрисовки на экране изменений на поле

**Методы**:

- `void moveCharacters()` - передвижение игрока на поле и врагов (враги делают шаг на каждый ход игрока)
- `void changeEquiption()` - изменение элемента инвентаря, который использует игрок
- `void destroyObstacle()` - разрушение игроком препятствия


<img src="images/model_component.png">


#### View
Графическое отображение игры
##### interface ApplicationView

Отвечает за отображение главного экрана игры.

**Методы**:
- `void showInitialScreen()` - отрисовывает экран, на котором есть следующие опции: `start game`, `start game with levels from file`,
  `show rules`, `exit`. Опция, которую выбирает игрок, выделена. Изначально выделена опция `start game`
- `void setSelectedItem` - изменяет выделенную опцию

**Реализация**:
- **class ApplicationViewConsole** - отображает все в консоли

##### interface GameRulesView

Отвечает за отображение экрана с правилами игры

**Методы**:
- `void showGameRules()` - отрисовывает экран, на котором выведены текстом правила игры

**Реализация**:
- **class GameRulesViewConsole** - отображает все в консоли

##### interface GameView

Отвечает за отображение самой игры

**Методы**:
- `void showBoard(int[][] board)` - выводит поле со всеми расположенными на нем объектами
- `void moveCharacter(Pair<int, int> from, Pair<int, int> to)` - клетку поля с координатами `from` отрисовывает пустой, а
  персонажа, который был на этом месте, отрисовывает в клетке с координатами `to`
- `void removeCharacter(Pair<int, int> from)` - отображает клетку с координатами `from` пустой
- `void placeCharacter(Character character, Pair<int, int> to)` - отображает в клетке с координатами `to` символ, соответствующий
  типу `character`
- `void showPoints(int points)` - отображает количество очков у персонажа.
- `void showLives(int lives)` - отображает сколько у персонажа осталось жизней
- `void showBackpack(Backpack bacpack)` - отображает рюкзак персонажа в следующем формате: предмет представлен в виде строчки
с названием этого предмета, кроме того есть строчка `nothing`, если игрок не подобрал пока ни одного предмета то
 в отображении рюкзака будет только она. Предмет, используемый игроком, выделен.
- `void setItemInBackpack()` - меняет выделенный предмет в рюкзаке

**Реализация**:
- **class GameViewConsole** - отображает все в консоли

##### interface AbstractViewFactory

Объявляет методы для создания различных абстрактных объектов типов `ApplicationView`, `GameRulesView`, `GameView`.
Введение данной фабрики добавляет гибкости в архитектуру, так как позволяет добавлять новые форматы отображения (например, по-разному отображать персонажей).
В случае, если придется изменить вывод, то достаточно будет создать другую реализацию
абстрактной фабрики.

**Методы**:
- `ApplicationView createApplicationView()`
- `GameRulesView createGameRulesView()`
- `GameView createGameView()`

**Реализация**:
- **class ConsoleViewFactory** - создает элементы типов `ApplicationViewConsole`, `GameRulesViewConsole` и `GameViewConsole`

##### Диаграмма:
<img src="images/view_component.png"/>


### Взаимодействия и состояния

#### Диаграмма последовательностей:

<img src="images/sequence_diag.png"/>

На диаграмме представлена реализация сценария выбора опции **show rules** в главном меню игры и последующий вывод правил на экран.

#### Диаграмма конечных автоматов:

<img src="images/state_machine.png"/>

На диаграмме представлена реализация сценария сбора очков игроком.

## Обоснование принятых решений:

### Архитектура:

Архитектурный стиль MVC был выбран, так как в нем четко и удобно разделена логика приложения, отдельная компонента для 
обработки ввода пользователя была выделена для достижения большей платформонезависимости остальных компонент

### Библиотека для графического отображения:
В итоге была выбрана библиотека [lanterna](https://github.com/mabe02/lanterna).

Во-первых, она оказалась достаточно простой в использовании, варианты рассматриваемые ранее показались нам слишком сложные для игры с консольной графикой.

Во-вторых, с помощью средств данной библиотеки оказалось возможным разделить логику ввода и отрисовки.



